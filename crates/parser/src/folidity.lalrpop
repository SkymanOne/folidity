use crate::lexer::{Token, LexicalError};
use crate::ast;
use lalrpop_util::ErrorRecovery;

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, LexicalError>>);

pub FolidityTree: ast::Source = {
    Expression* => ast::Source { expressions: <> }
}




Expression: ast::Expression = {
    #[precedence(level="0")]
    Term,

    #[precedence(level="1")] #[assoc(side="left")]
    <start:@L> <e:Expression> "." <start2:@L>  <i:ident> <end:@R> => {
        ast::Expression::MemberAccess(
            ast::MemberAccess::new(start, end, Box::new(e), ast::Identifier::new(start2, end, i.to_string()))
        )
    },

    #[precedence(level="2")] #[assoc(side="left")]
    <start:@L> <lhs:Expression> "*" <rhs:Expression> <end:@R> => {
        ast::Expression::Multiply(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },

    <start:@L> <lhs:Expression> "/" <rhs:Expression> <end:@R> => {
        ast::Expression::Divide(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },
    <start:@L> <lhs:Expression> "%" <rhs:Expression> <end:@R> => {
        ast::Expression::Divide(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <start:@L> <lhs:Expression> "+" <rhs:Expression> <end:@R> => {
        ast::Expression::Add(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },
    <start:@L> <lhs:Expression> "-" <rhs:Expression> <end:@R> => {
        ast::Expression::Subtract(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },


    #[precedence(level="4")] #[assoc(side="left")]
    <start:@L> <lhs:Expression> ":>" <rhs:Expression> <end:@R> => {
        ast::Expression::Pipe(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },
    

    #[precedence(level="5")]
    <start:@L> "!" <val:Expression> <end:@R> => {
        ast::Expression::Not(
            ast::UnaryExpression::new(start, end, Box::new(val))
        )
    },

}

Term: ast::Expression = {
    <start:@L> <val:ident> <end:@R> => {
        ast::Expression::Variable(
            ast::Identifier::new(start, end, val.to_string())
        )
    },

    <start:@L> <val:number> <end:@R> => {
        ast::Expression::Number(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:float> <end:@R> => {
        ast::Expression::Float(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:string> <end:@R> => {
        ast::Expression::String(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:char_token> <end:@R> => {
        ast::Expression::Char(
            ast::UnaryExpression::new(start, end, val)
        )
    },
    <start:@L> <val:hex> <end:@R> => {
        ast::Expression::Hex(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:address> <end:@R> => {
        ast::Expression::Address(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },


    "(" <Expression> ")" => <> 
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        number => Token::Number(<&'input str>),
        float => Token::Float(<&'input str>),
        char_token => Token::Char(<char>),
        string => Token::String(<&'input str>),
        address => Token::Address(<&'input str>),
        hex => Token::String(<&'input str>),
        ident => Token::Identifier(<&'input str>),
        "true" => Token::True,
        "false" => Token::False,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LCurly,
        "}" => Token::RCurly,
        "<" => Token::LAngle,
        ">" => Token::RAngle,
        "=" => Token::Assign,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Modulo,
        "!" => Token::Not,
        "==" => Token::Eq,
        "/=" => Token::Neq,
        "<=" => Token::Leq,
        ">=" => Token::Meq,
        "in" => Token::In,
        "||" => Token::Or,
        "&&" => Token::And,
        "int" => Token::IntType,
        "uint" => Token::UIntType,
        "float" => Token::FloatType,
        "char" => Token::CharType,
        "string" => Token::StringType,
        "hex" => Token::HexType,
        "address" => Token::AddressType,
        "bool" => Token::BoolType,
        "()" => Token::UnitType,
        "Mapping" => Token::Mapping,
        "Set" => Token::Set,
        "List" => Token::List,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "state" => Token::State,
        "fn" => Token::Func,
        "from" => Token::From,
        "return" => Token::Return,
        "range" => Token::Range,
        "for" => Token::For,
        "to" => Token::To,
        "if" => Token::If,
        "else" => Token::Else,
        "st" => Token::St,
        "when" => Token::When,
        "pub" => Token::Pub,
        "view" => Token::View,
        "@init" => Token::Init,
        "version" => Token::Version,
        "author" => Token::Author,
        "let" => Token::Let,
        "mut" => Token::Mut,
        "->" => Token::Arr,
        ";" => Token::SemiCol,
        ":" => Token::Col,
        "@" => Token::At,
        ":>" => Token::Pipe,
        "|" => Token::MatchOr,
        "." => Token::Dot,
        ".." => Token::DoubleDot,
    }
}