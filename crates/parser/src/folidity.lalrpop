use crate::lexer::{Token, LexicalError};
use crate::ast;
use lalrpop_util::ErrorRecovery;

grammar<'input, 'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, LexicalError>>);

pub FolidityTree: ast::Source = {
    Declaration* => ast::Source { declarations: <> }
}

Declaration: ast::Declaration = {

}


AccessAttr: ast::AccessAttribute = {
    <start:@L> "@" "(" <memebers:(<Expression> "|")+> ")" <end:@R> => {
        ast::AccessAttribute::new(start, end, memebers)
    }
}

FunctionVis: ast::FunctionVisibility = {
    "pub" => ast::FunctionVisibility::Pub,

    <start:@L> "view" "(" <param:StateParam> ")" <end:@R> => {
        ast::FunctionVisibility::View(
            ast::ViewState::new(start, end, param)
        )
    }
}

StateParam: ast::StateParam = {
    <start:@L> <ty:Identifier> <name_op:Identifier?> <end:@R> => {
        let n = match name_op {
            Some(i) => Some(i),
            None => None,
        };
        ast::StateParam::new(start, end, ty, n)
    } 
}

FuncReturnType: ast::FuncReturnType = {
    "(" <pt:Param> ")" => ast::FuncReturnType::ParamType(pt),

    <t:Type> => ast::FuncReturnType::Type(t),
}

Param: ast::Param = {
    <start:@L> <i:Identifier> ":" <t:Type> <end:@R> => {
        ast::Param::new(start, end, t, i)
    } 
}

StateBound: ast::StateBound = {
    "when" <start:@L> <from:StateParam> "->" <to:StateParam> <end:@R> => {
        ast::StateBound::new(start, end, from, to)
    }
}

StBlock: ast::StBlock = {
    "{" <start:@L> <exprs:(<Expression> ",")+> <end:@R> "}" => {
        ast::StBlock::new(start, end, exprs)
    },

    <start:@L> <e:Expression> <end:@R> => {
        ast::StBlock::new(start, end, vec![e])
    }
}

StatementBlock: ast::StatementBlock = {
    <start:@L> "{" <statements:Statement*> "}" <end:@L> => {
        ast::StatementBlock::new(start, end, statements)
    }
}


Statement: ast::Statement = {
    <block:StatementBlock> => ast::Statement::Block(block) 
}

Expression: ast::Expression = {
    #[precedence(level="0")]
    Term,

    #[precedence(level="1")] #[assoc(side="left")]
    <start:@L> <e:Expression> "." <i:Identifier> <end:@R> => {
        ast::Expression::MemberAccess(
            ast::MemberAccess::new(start, end, Box::new(e), i)
        )
    },

    #[precedence(level="2")] #[assoc(side="left")]
    <start:@L> <lhs:Expression> "*" <rhs:Expression> <end:@R> => {
        ast::Expression::Multiply(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },

    <start:@L> <lhs:Expression> "/" <rhs:Expression> <end:@R> => {
        ast::Expression::Divide(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },
    <start:@L> <lhs:Expression> "%" <rhs:Expression> <end:@R> => {
        ast::Expression::Divide(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },

    #[precedence(level="3")] #[assoc(side="left")]
    <start:@L> <lhs:Expression> "+" <rhs:Expression> <end:@R> => {
        ast::Expression::Add(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },
    <start:@L> <lhs:Expression> "-" <rhs:Expression> <end:@R> => {
        ast::Expression::Subtract(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },


    #[precedence(level="4")] #[assoc(side="left")]
    <start:@L> <lhs:Expression> ":>" <rhs:Expression> <end:@R> => {
        ast::Expression::Pipe(
            ast::BinaryExpression::new(start, end, Box::new(lhs), Box::new(rhs))
        )
    },
    

    #[precedence(level="5")]
    <start:@L> "!" <val:Expression> <end:@R> => {
        ast::Expression::Not(
            ast::UnaryExpression::new(start, end, Box::new(val))
        )
    },

}

Term: ast::Expression = {
    <i:Identifier> => {
        ast::Expression::Variable(i)
    },

    <start:@L> <val:number> <end:@R> => {
        ast::Expression::Number(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:float> <end:@R> => {
        ast::Expression::Float(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:string> <end:@R> => {
        ast::Expression::String(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:char_token> <end:@R> => {
        ast::Expression::Char(
            ast::UnaryExpression::new(start, end, val)
        )
    },
    <start:@L> <val:hex> <end:@R> => {
        ast::Expression::Hex(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },
    <start:@L> <val:address> <end:@R> => {
        ast::Expression::Address(
            ast::UnaryExpression::new(start, end, val.to_string())
        )
    },


    "(" <Expression> ")" => <> 
}

Type: ast::Type = {
    <start:@L> "int" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Int),
    <start:@L> "uint" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Uint),
    <start:@L> "float" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Float),
    <start:@L> "char" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Char),
    <start:@L> "string" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::String),
    <start:@L> "hex" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Hex),
    <start:@L> "address" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Address),
    <start:@L> "()" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Unit),
    <start:@L> "bool" <end:@R> => ast::Type::new(start, end, ast::TypeVariant::Bool),
}

Identifier: ast::Identifier = {
    <start:@L> <i:ident> <end:@L> => ast::Identifier::new(start, end, i.to_string())
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        number => Token::Number(<&'input str>),
        float => Token::Float(<&'input str>),
        char_token => Token::Char(<char>),
        string => Token::String(<&'input str>),
        address => Token::Address(<&'input str>),
        hex => Token::String(<&'input str>),
        ident => Token::Identifier(<&'input str>),
        "true" => Token::True,
        "false" => Token::False,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LCurly,
        "}" => Token::RCurly,
        "<" => Token::LAngle,
        ">" => Token::RAngle,
        "=" => Token::Assign,
        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Mul,
        "/" => Token::Div,
        "%" => Token::Modulo,
        "!" => Token::Not,
        "==" => Token::Eq,
        "/=" => Token::Neq,
        "<=" => Token::Leq,
        ">=" => Token::Meq,
        "in" => Token::In,
        "||" => Token::Or,
        "&&" => Token::And,
        "int" => Token::IntType,
        "uint" => Token::UIntType,
        "float" => Token::FloatType,
        "char" => Token::CharType,
        "string" => Token::StringType,
        "hex" => Token::HexType,
        "address" => Token::AddressType,
        "bool" => Token::BoolType,
        "()" => Token::UnitType,
        "Mapping" => Token::Mapping,
        "Set" => Token::Set,
        "List" => Token::List,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "state" => Token::State,
        "fn" => Token::Func,
        "from" => Token::From,
        "return" => Token::Return,
        "range" => Token::Range,
        "for" => Token::For,
        "to" => Token::To,
        "if" => Token::If,
        "else" => Token::Else,
        "st" => Token::St,
        "when" => Token::When,
        "pub" => Token::Pub,
        "view" => Token::View,
        "@init" => Token::Init,
        "version" => Token::Version,
        "author" => Token::Author,
        "let" => Token::Let,
        "mut" => Token::Mut,
        "->" => Token::Arr,
        ";" => Token::SemiCol,
        ":" => Token::Col,
        "@" => Token::At,
        ":>" => Token::Pipe,
        "|" => Token::MatchOr,
        "." => Token::Dot,
        ".." => Token::DoubleDot,
        "," => Token::Coma,
    }
}