%% ----------------------------------------------------------------
%% Progress.tex
%% ---------------------------------------------------------------- 

\documentclass[oneside]{ecsproject}     % Use the Project Style
\usepackage{titlesec}
\usepackage{makecell}
\usepackage{pgfgantt}
\usepackage{pdflscape}
\usepackage[outputdir=output]{minted}

\titleformat{\chapter}
  {\normalfont\huge\bfseries}{\ \thechapter.}{18pt}{\huge}
\graphicspath{{figures/}}   % Location of your graphics files
\usepackage{natbib}            % Use Natbib style for the refs.
\hypersetup{colorlinks=false}   % Set to false for black/white printing

\newcommand{\vref}[1]{\textit{\hyperref[#1]{#1}}}
\newcommand{\lref}[1]{Listing~\ref{#1}}

\begin{document}
\frontmatter
\title      {Folidity - Safe Functional Smart Contract Language}
\authors    {\texorpdfstring
             {\href{mailto:gn2g21@soton.ac.uk}{German Nikolishin}}
             {German Nikolishin}
            }
\addresses  {\groupname\\\deptname\\\univname}
\date       {\today}
\subject    {}
\keywords   {}
\supervisor {\texorpdfstring
            {\href{mailto:gn2g21@soton.ac.uk}{Prof. Vladimiro Sassone}}
            {Prof. Vladimiro Sassone}
}
\examiner   {Dr Butthead}
\degree     {BSc Computer Science}
\maketitle
\tableofcontents
% \listoffigures
% \listoftables
% \lstlistoflistings
% \listofsymbols{ll}{$w$ & The weight vector}
\mainmatter
%% ----------------------------------------------------------------

\chapter{Introduction}

The idea of "smart contract" [SC] was first coined by Nick Szabo as a computerised transaction protocol \cite{nz_sc}.
He later defined smart contracts as observable, verifiable, privity-applicable, and enforceable programs. \cite{nz_sc_bb}.
In other words, it was envisioned for smart contracts to inherit the natural properties of the traditional
"paper-based" contracts.

It was only in 2014 when SCs were technically formalised at the protocol level by Dr. Gavin Wood, as an arbitrary program
written in some programming language (Solidity) and executed in the blockchain's virtual machine of Ethereum (EVM) \cite{eth_yellow_paper}.

Ethereum Virtual Machine (EVM) iterated over the idea of Bitcoin Scripting allowing developers to deploy general-purpose, Turing-Complete
programs that can have own storage, hence state. This enabled the development of more sophisticated applications that grew beyond
the simple transfers of funds among users.

Overall, SC can be summarised as an \textit{immutable}, \textit{permissionless}, \textit{deterministic} computer programs 
that are executed as part of state transition in the blockchain system. 
At the time of writing, Solidity is still the most widely used SC language (SCL) \cite{sc_survey}.

After a relatively short time, SCs have come a long way and allowed users to access different online services in a completely trustless and decentralised way.
The applications have spanned across financial, health, construction\cite{cad_blockchain}, and other sectors. 

\chapter{Security and Safety of Smart Contracts}

\section{Overview}

With the increased adoption of decentralised applications (DApps) and the increased total value locked in DApps, 
there has been evidence of numerous attacks and exploits focused on extracting funds from SCs. 
Due to the permissionless nature of SCs, the most common attack vector is exploiting the mistakes in the SC's source code.
Specifically, the attacker can not tamper with the protocol code due to consensus mechanisms.
Instead, they can cleverly tamper with the publicly accessible parameters and interfaces to force the SC into an unexpected state, essentially gaining partial control of it.

A notorious example of such attacks is the DAO hack when hackers exploited unprotected re-entrance calls to withdraw \textbf{\$50 million worth of ETH}. 
This event forced the community to hard-fork the protocol to revert the transaction provoking a debate on the soundness of the action \cite{the_dao}.

Another less-known example is the "King of the Ether" attack which was caused by the unchecked low-level Solidity \texttt{send} call to transfer funds to a contract-based wallet \cite{king_of_the_ether}.
The "King of the Ether Throne" contract was not able to recognise the failed transaction on the wallet side. Instead, the contract proceeded with the operation, incorrectly mutating its internal state.

Other issues involve the \textit{safety} and \textit{liveness} of SCs. 
The term \textit{safety} is used to describe the \textit{functional safety} and \textit{type safety}. It is often used interchangeably with the \textit{security} of code
as compromising the former has effects on the latter. When talking about \textit{liveness}, we describe the business logic of a DApp, in particular, whether it transitions into the expected new state.

\textit{Safety} and \textit{liveness} can be compromised due to the programmer's mistakes in the source code that can result in the SC entering the terminal unexpected state
preventing users from interacting with it\cite{ondo_report}.


\section{Vulnerability classification}

There has been an effort in both academia and industry to classify common vulnerabilities 
and exploits in SCs in blockchain systems \cite{owasp}\cite{stefano}\cite{atzei_survey}. 
Some of the work has been recycled by bug bounty platforms growing the community of auditors
and encouraging peer-review of SCs such as \textit{Code4rena}\footnote{https://code4rena.com}, \textit{Solodit}\footnote{https://solodit.xyz},
and many others.

Analysing the work mentioned above, SCs vulnerabilities can be categorised into the 6 general groups that are outlined in \tref{Table:classification}.

\begin{table}[!htb]
  \centering
  \begin{tabular}{ccc}
  \toprule
  \textbf{Code} & \textbf{Title} & \textbf{Summary}\\
  \midrule
  \textit{SCV1}\label{SCV:1} & \makecell{Timestamp\\manipulation} & \makecell{\\Timestamp used in \\control-flow, randomness and storage,\\can open an exploit due to an ability\\for validator to manipulate the timestamp}\\\\
  \hline
  \textit{SCV2}\label{SCV:2} & \makecell{Pseudo-randomness} & \makecell{\\Using block number, block hash,\\block timestamp\\are not truly random generated parameters,\\and can be manipulated by the adversary validator}\\\\
  \hline
  \textit{SCV3}\label{SCV:3} & \makecell{Invalidly-coded\\states} & \makecell{\\When coding business logic,\\ control-flow checks\\can be incorrectly coded resulting the SC\\entering into invalid state}\\\\
  \hline
  \textit{SCV4}\label{SCV:4} & \makecell{Access Control\\exploits} & \makecell{\\This is a more broad categorisation of vulnerabilities.\\It occurs when an adversary calls a restricted function.\\This is specifically present in\\\textit{upgradeability} and \textit{deleteability} of SCs}\\\\
  \hline
  \textit{SCV5}\label{SCV:5} & \makecell{Arithmetic operations} & \makecell{\\SCs are suspected to the same arithmetic bugs\\as classic programs.\\Therefore, unchecked operations can result\\in underflow/overflow or deletion by zero}\\\\
  \hline
  \textit{SCV6}\label{SCV:6} & \makecell{Unchecked externall\\calls} & \makecell{\\Unchecked re-entrant, forward, delegate\\calls can result in the contract\\entering into unexpected state}\\\\
  \bottomrule
  \end{tabular}
  \caption{classification of SC Vulnerabilities}
  \label{Table:classification}
\end{table}

Note that we do not evaluate the listed vulnerabilities based on their severity. 
As far as this paper is concerned, all vulnerabilities are considered to be of equal weight for the reasons described in \sref{Section:Scene}.

\section{Setting the scene} \label{Section:Scene}

Numerous deployed DApps allowed the community of developers and auditors to learn from the mistakes and the past,
and generally improve the code quality and security of SCs. Audits are now an essential part of the release cycle of any DApp.

However, even with the raised awareness for the security and safety of SCs, recent reports from "code4rena" still show \vref{SCV:3}, \vref{SCV:4} and \vref{SCV:5}
commonly present in the recent audit reports\cite{arcade_report}\cite{ondo_report}\cite{centrifuge_report}.

In particular, in \cite{centrifuge_report} a relatively simple calculation mistake resulted in other SC users being unable to withdraw their funds.

It can be seen that SC Vulnerabilities illustrated in \tref{Table:classification} are still evident in modern SCs resulting in opening them up to vulnerabilities of different severity levels.
Looking at the mentioned reports, there is little consensus about the weight of each vulnerability.
Therefore, as mentioned earlier, we can not classify any particular vulnerability to be more severe than the other as it solely depends on the context in the code it is present in.
Furthermore, given the pattern in the mistakes made by SC developers, 
it has been realised that additional tooling or alternative SCLs need to be discovered to minimise the exposure of SC code to the earlier-mentioned vulnerabilities.

\chapter{Current Solutions}

\section{Overview}

As mentioned earlier, given the increased use of SCs and the consistency in the presence of vulnerabilities and programmer mistakes
different solutions have been presented to attempt to mitigate those. 
We can generally categorise them into 2 groups: safe SCLs which allow users to write safe and secure code, particularly described in \cref{Chapter:SCL}, 
and formal verification tools which are used alongside traditional SCLs and are described in \cref{Chapter:FVT}.

At the end of the chapter, we will have reviewed both categories of tools allowing us to evaluate their effectiveness in correlation to usability.
Particularly, this chapter aims to provide a clear and concise framework to analyze and work with the SC tools dedicated to producing
error-proof DApps. 

\section{Solidity: the good and the bad}

Before we begin the analysis of existing solutions, it is essential to introduce the first and most popular SCL, Solidity\cite{sc_survey}\cite{solidity_docs}.
Solidity has paved the way for SC development and become a de facto standard in the blockchain space. We will later discover a lot of similarities with Solidity in other SCLs.
Understanding the way Solidity works will enable us to understand its limitations, and how other SCLs and toolings try to address them.

Solidity is a domain-specific, object-oriented\footnote{It is also often referred to as \textit{contract-oriented}. We will use these terms interchangeably.}, statically-typed, compiled
programming language\cite{solidity_docs}.

Looking at the \lref{Listing:solidity}, we can identify some similarities with the OOP languages and C-like syntax.
In particular, Solidity shares visibility keywords on lines \textit{6} and \textit{20}, variable declarations, methods.
Noting the differences, Solidity has blockchain-specific data types such as \textit{address} which intuitively represents an address on the system.
Importantly, functions have to be declared \textit{public} in order to be callable externally by the user or other contracts.
We can also see the event declaration on the line \textit{7}, which allows EVM to log an action on the system to be accessed by the client.
Solidity also offers specific functions, called modifiers that allow for a change of behaviour of the function it is used on\cite{solidity_docs}.
Finally, \textit{view} keyword allows that the function does not modify the state and only reads from it.
Other specification details are omitted as they touch upon more EVM-specific functionality.

It is evident from the listing the similarity of Solidity with other C-inspired systems languages that reduces
the learning curve and makes it more appealing for developers to pick up.
The syntax simplicity also enables clarity in reading the code and auditing it. The imperative, and object-oriented style
provides additional familiarity for developers allowing them to think of an individual contract as a class object.

\begin{listing}
\begin{minted}[linenos]{c}
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

contract Owner {

    address private owner;
    event OwnerSet(address indexed oldOwner, address indexed newOwner);

    modifier isOwner() {
        require(msg.sender == owner, "Caller is not owner");
        _;
    }

    constructor() {
        console.log("Owner contract deployed by:", msg.sender);
        owner = msg.sender;
        emit OwnerSet(address(0), owner);
    }

    function changeOwner(address newOwner) public isOwner {
        emit OwnerSet(owner, newOwner);
        owner = newOwner;
    }

    function getOwner() external view returns (address) {
        return owner;
    }
}
\end{minted}
\caption{Simple Solidity contract}
\label{Listing:solidity}
\end{listing}

On the other side, programming in Solidity comes with similar challenges as its parents. 
Developers need to be aware of its operations on memory and storage when designing complex storage applications, 
how the execution stack is handled at the VM level, 
and implications on the use of unchecked arithmetic operations \vref{SCV:5}.
Additionally, the vulnerabilities listed in \tref{Table:classification} 
has been mainly composed of Solidity SC exploits.
Moreover, the immutable nature of SCs restricts the iterative approach in development,
posing an even greater responsibility on developers to carefully model and design programs.
This is where formal verification tools have found strong applications.

\section{Formal Verification Tools} \label{Chapter:FVT}
\paragraph*{}
Formal verification describes the assessment of the correctness of a system with respect
to a formal specification\cite{eth_formal_verification}. The specification is usually described
in terms of models that are verified using mathematical proofs. There are multiple ways to formally verify a program
that are focused on the specific parts of it. \textit{Model checking} utilises propositional logic 
to verify the mathematical abstractions of the system. \textit{Theorem proving} involves the verification of
relations between the model and the statements about the system. Finally, \textit{symbolic execution} focuses
on the execution of the program using symbolic values instead of concrete values\cite{eth_formal_verification}.
Different tools utilise different combinations of methods mentioned above. We are going to look at a couple of them.

KEVM\footnote{https://jellopaper.org/index.html} is a tool that provides an executable semantics of EVM using $\mathbb{K}$ framework. 
It uses reachability logic to reason symbolically about the system\cite{kevm}. KEVM is a powerful tool that operates at the EVM bytecode level.
Specifically, SC developers are required to write a specification in a separate file that is checked against the compiled EVM bytecode of the SC.
Whilst this provides more fine-grained assurance of the safety and correctness, it requires specialised knowledge of the $\mathbb{K}$ framework and EVM
semantics, hence, significantly increasing the development time.

The other interesting tool is Dafny\footnote{https://dafny.org/latest/DafnyRef/DafnyRef}. Dafny is a general-purpose tool that checks inputs in any language 
using Hoare-logic and high-level annotations. Although Dafny offers compilation to some system languages, Solidity is not yet a supported target. 
Notably, work in the field suggests that the Dafny can be an effective and easy-to-use tool to produce a formal specification\cite{dafny_deductive}.
The syntax resembles a traditional imperative style and is substantially easier to learn and understand than KEVM.

Going further, there are tools that can used alongside Solidity code such as Scribble\footnote{https://docs.scribble.codes/}. 
Scribble enables developers to provide formal specification of functions inside docstrings seamlessly integrating with existing 
Solidity code. It offers VS Code extensions and is actively maintained by Consensys. 
The trade-off is the limited expressiveness in comparison with KEVM and Dafny.

Finally, there have been experiments to formally verify SC without any additional annotations. In particular, VeriSmart specifically
focuses on ensuring arithmetic safety and preciseness in SCs\cite{so2019verismart}. However, VeriSmart fails to detect other types of errors, 
although the effort to apply to verifier to more areas of SC has been made.

\paragraph*{}
Formal verification is a multi-disciplinary field offering multiple ways of reason about the systems. One of the actively researched fields
is bounded model verification\cite{SMBC}. Developers are required to reason about the programs as finite state machines (FSM).
This reasoning approach is more apparent in SC development since the state transition is at the core of blockchain execution.
Bounded model checking has been realised by only a few experimental projects such as Solidifier\cite{solidifer}, and Microsoft\cite{azure}.
Both words attempt to translate Solidity code to an intermediate modeling language, Boogie\cite{boogie}. Boogie then leverages
SMT solvers in order to find any assertion violations.

All in all, we can see that formal verification tools provide a robust way of ensuring the safety and security of SCs. 
While significant effort has been made in the field, it is evident that formal verification tools in SC development
try to compensate for Solidity's implicit state transitions and lack of \textit{implicit} safety. 
Furthermore, the current tools significantly complicate the development process and provide very little comfort
for developers to opt-in for them.

\section{Safe Smart Contract Languages} \label{Chapter:SCL}

As mentioned above, Solidity imperative programming style compromises a safe development process. Therefore,
multiple attempts have been made to address a flawed programming model\cite{sc_survey}. Alternative SCLs aim at providing
built-in safety features in a type system, modeling, and function declaration in order to minimise the need for
external tooling. 

Some languages, such as Vyper\footnote{https://docs.vyperlang.org/en/latest/index.html}, strive for simplicity.
By stripping off some low-level features, Vyper minimises the chances of the developer misusing the dangerous operations.
It also provides overflow checking, signed integers, and other safe arithmetic operations. However, Vyper is still immature 
and the recent bug in the compiler caused a massive re-entrancy exploit in the \textit{curve.fi} AMM protocol\cite{curve}.
Furthermore, Vyper still suffers from the same implicit state transition problem as Solidity.

To address the problem, it has been realised that a functional programming style may suit better for SC development due to
an explicit approach to reason about a state transition. Although some small effort has been made in adapting Haskell,
neither of the projects received any long-term support. It is still worth looking at some of the languages that suggest novice approaches to development. 

Flint is an experiment language with protected calls and asset types\cite{flint}. Protected calls introduce a role-based access system
where the SC developer can specify the permitted caller to a message function. Another unique feature is array-bounded loops
that partially address the halting problem. Flint also addresses a state-transition problem by allowing developers to specify
all possible states in the contract. The message functions then need to explicitly specify then the state transition occurs.
The language provides a significant improvement in a modeling approach. However, it still lacks the modeling SC input data in terms
of constraints and invariants, and explicit state transition is still an optional feature that the developer can miss in using.

Another promising SCL reasons about SC development through dependent and polymorphic types\cite{idris}. It extends Idris\footnote{https://www.idris-lang.org}.
It makes the developer model the SC as part of a state transition function by adopting a functional programming style. Dependent types provide a more
fine-grained controller over the input and output data that flow through the SC functions. In particular, similar to Haskell, the language offers \textit{side-effects} 
functionality that resembles \textit{IO} monads in Haskell. The downside of the approach is that the syntax has become too cumbersome for other developers to learn. Thus,
it has been stated that the language does not strive for simplicity and sacrifices it for safety.


\section{Problem statement}

Analysing the solutions mentioned earlier, we can identify the positive trend in providing the safety and security of SCs.
Modern formal verification methods offer support to SC developers in ensuring that their code satisfies the requirements of the system, while
proposed SCL solutions offer runtime safety minimising the need for the former.

However, there has been no effort in attempting to combine the two approaches into a single development process. Formal verification tools
focus on the validation of functional correctness and model consistency of a program at the compile time, whereas SCLs focus on data validation 
at the runtime. Recent work suggests that the improved optimisation of SMT solvers allows us to turn the formal model specification into 
the runtime assertions\cite{runtime_assert}. Furthermore, no effort has been made to minimise false negatives in SC formal modeling, 
even though the methods have been developed for traditional systems\cite{even_b}.

%% ----------------------------------------------------------------

\chapter{Proposed Solution} \label{Chapter:Solution}


\chapter{Project Planning}



%% ----------------------------------------------------------------

\appendix

\chapter{Gannt Chart}
\begin{landscape}
  \begin{figure}[tbp]
      \centering
      \begin{ganttchart}[y unit title=0.5cm,
      y unit chart=0.5cm,
      vgrid,hgrid,
      % title label anchor/.style={below=-1.6ex},
      % title left shift=.05,
      % title right shift=-.05,
      title height=1.5,
      progress label text={$\displaystyle #1 \% $},
      bar height=0.8,
      % group right shift=0,
      group top shift=.8,
      ]{1}{30}
      %labels
      \gantttitle{\bf{Month}}{30} \\ \\
      \gantttitle{October}{4} 
      \gantttitle{November}{4} 
      \gantttitle{December}{4} 
      \gantttitle{January}{4} 
      \gantttitle{February}{4} 
      \gantttitle{March}{4}
      \gantttitle{April}{4}
      \gantttitle{May}{2} \\
      %tasks
      \ganttgroup[progress=100]{Overview of SC vulnerabilities}{1}{9} \\
      \ganttbar[progress=100]{Common smart contract exploits}{2}{7} \\
      \ganttbar[progress=100]{Survey of SC languages}{3}{8} \\
      \ganttbar[progress=100]{Formal verification analysis}{6}{9} \\
      \ganttbar[progress=100]{Evaluation of current solutions and issues}{6}{8} \\ \\
  
      \ganttmilestone{Progress Report}{9} \\
  
      \ganttgroup[progress=22.5]{The design of the proposed solution}{7}{14} \\
      \ganttbar[progress=60]{Requirements}{7}{8} \\
      \ganttbar[progress=30]{BNF Grammar}{7}{9} \\
      \ganttbar[progress=0]{Sample programs}{9}{12} \\
      \ganttbar[progress=0]{Brief evaluation of the BNF grammar}{12}{14} \\ \\
  
      \ganttgroup[progress=0]{Implementation}{12}{24} \\
      \ganttbar[progress=0]{Syntax}{12}{14} \\
      \ganttbar[progress=0]{Type Checker}{15}{18} \\
      \ganttbar[progress=0]{Evaluator}{18}{24} \\
      \ganttbar[progress=0]{Model Checker}{18}{21} \\
      \ganttbar[progress=0]{Functional correctness checker}{20}{23} \\ \\
  
      \ganttgroup[progress=0]{Evaluation}{23}{28} \\ 
      \ganttbar[progress=0]{Testing}{23}{26} \\
      \ganttbar[progress=0]{Safety evaluation}{27}{27} \\
      \ganttbar[progress=0]{Overview of sample solutions}{27}{27} \\
      \ganttbar[progress=0]{Future work}{28}{28} \\ \\
  
      \ganttmilestone{Submission Deadline}{28}
      %relations 
  
      \end{ganttchart}
      \caption{Gantt Chart}
  
  \end{figure}
  \end{landscape}

%% ----------------------------------------------------------------


\backmatter
\bibliographystyle{unsrt}
\bibliography{ECS}
\include{AppendixA}
\end{document}
%% ----------------------------------------------------------------
